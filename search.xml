<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Axios</title>
    <url>/2022/08/02/Axios/</url>
    <content><![CDATA[<blockquote>
<p>git的一些基础操作</p>
</blockquote>
<span id="more"></span>

<h1 id="axios从入门到源码分析"><a href="#axios从入门到源码分析" class="headerlink" title="axios从入门到源码分析"></a>axios从入门到源码分析</h1><h2 id="1-前后台交互的基本过程"><a href="#1-前后台交互的基本过程" class="headerlink" title="1. 前后台交互的基本过程"></a>1. 前后台交互的基本过程</h2><pre><code>1. 前后应用从浏览器端向服务器发送HTTP请求(请求报文)
2. 后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文)
3. 浏览器端接收到响应, 解析显示响应体/调用监视回调
</code></pre>
<h2 id="2-HTTP请求报文"><a href="#2-HTTP请求报文" class="headerlink" title="2. HTTP请求报文"></a>2. HTTP请求报文</h2><pre><code>1. 请求行: 请求方式/url
2. 多个请求头: 一个请求头由name:value组成, 如Host/Cookie/Content-Type头
3. 请求体
</code></pre>
<h2 id="3-HTTP响应报文"><a href="#3-HTTP响应报文" class="headerlink" title="3. HTTP响应报文"></a>3. HTTP响应报文</h2><pre><code>1. 响应行: 响应状态码/对应的文本
2. 多个响应头: 如 Content-Type / Set-Cookie 头
3. 响应体
</code></pre>
<h2 id="4-post请求体文本参数格式"><a href="#4-post请求体文本参数格式" class="headerlink" title="4. post请求体文本参数格式"></a>4. post请求体文本参数格式</h2><pre><code>1. Content-Type: application/x-www-form-urlencoded;charset=utf-8
    用于键值对参数，参数的键值用=连接, 参数之间用&amp;连接
    例如: name=%E5%B0%8F%E6%98%8E&amp;age=12
2. Content-Type: application/json;charset=utf-8
    用于json字符串参数
    例如: &#123;&quot;name&quot;: &quot;%E5%B0%8F%E6%98%8E&quot;, &quot;age&quot;: 12&#125;
</code></pre>
<h2 id="5-常见响应状态码"><a href="#5-常见响应状态码" class="headerlink" title="5. 常见响应状态码"></a>5. 常见响应状态码</h2><pre><code>200	OK                     请求成功。一般用于GET与POST请求
201 Created                已创建。成功请求并创建了新的资源
401 Unauthorized           未授权/请求要求用户的身份认证
404 Not Found              服务器无法根据客户端的请求找到资源
500 Internal Server Error  服务器内部错误，无法完成请求
</code></pre>
<h2 id="6-不同类型的请求及其作用"><a href="#6-不同类型的请求及其作用" class="headerlink" title="6. 不同类型的请求及其作用:"></a>6. 不同类型的请求及其作用:</h2><pre><code>1. GET: 从服务器端读取数据
2. POST: 向服务器端添加新数据
3. PUT: 更新服务器端已经数据
4. DELETE: 删除服务器端数据
</code></pre>
<h2 id="7-API的分类"><a href="#7-API的分类" class="headerlink" title="7. API的分类"></a>7. API的分类</h2><pre><code>1. REST API:    restful
    发送请求进行CRUD哪个操作由请求方式来决定
    同一个请求路径可以进行多个操作
    请求方式会用到GET/POST/PUT/DELETE
2. 非REST API:   restless
    请求方式不决定请求的CRUD操作
    一个请求路径只对应一个操作
    一般只有GET/POST
测试: 可以使用json-server快速搭建模拟的rest api 接口
</code></pre>
<h2 id="8-理解XHR"><a href="#8-理解XHR" class="headerlink" title="8. 理解XHR"></a>8. 理解XHR</h2><pre><code>使用XMLHttpRequest (XHR)对象可以与服务器交互, 也就是发送ajax请求
前端可以获取到数据，而无需让整个的页面刷新。
这使得Web页面可以只更新页面的局部，而不影响用户的操作。
</code></pre>
<h2 id="9-XHR的基本使用"><a href="#9-XHR的基本使用" class="headerlink" title="9. XHR的基本使用"></a>9. XHR的基本使用</h2><ol>
<li><p>步骤：</p>
<p>（1）创建xhr对象</p>
<p>（2）调用xhr.open()函数</p>
<p>（3）设置Content-Type属性</p>
<p>（4）调用xhr.send()函数</p>
<p>（5）监听xhr.onreadStatechange()事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"> </span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://maowei.api.tp6:8000/user&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&#x27;id=2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">xhr.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span>===<span class="number">4</span> || xhr.<span class="property">status</span>===<span class="number">200</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="10-区别ajax请求与一般HTTP请求"><a href="#10-区别ajax请求与一般HTTP请求" class="headerlink" title="10. 区别ajax请求与一般HTTP请求"></a>10. 区别ajax请求与一般HTTP请求</h2><pre><code>ajax请求是一种特别的http请求: 只有通过XHR/fetch发送的是ajax请求, 其它都是一般HTTP请求
对服务器端来说, 没有任何区别, 区别在浏览器端
浏览器端发请求: 只有XHR或fetch发出的才是ajax请求, 其它所有的都是非ajax请求
浏览器端接收到响应
    一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面
    ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据
</code></pre>
<h2 id="11-使用XHR封装一个发ajax请求的通用函数"><a href="#11-使用XHR封装一个发ajax请求的通用函数" class="headerlink" title="11. 使用XHR封装一个发ajax请求的通用函数"></a>11. 使用XHR封装一个发ajax请求的通用函数</h2><pre><code>函数的返回值为promise, 成功的结果为response, 异常的结果为error
能处理多种类型的请求: GET/POST/PUT/DELETE
函数的参数为一个配置对象: url/method/params/data
响应json数据自动解析为了js
</code></pre>
<h2 id="12-axios的特点"><a href="#12-axios的特点" class="headerlink" title="12. axios的特点"></a>12. axios的特点</h2><pre><code>基于promise的封装XHR的异步ajax请求库
浏览器端/node端都可以使用
支持请求／响应拦截器
支持请求取消
请求/响应数据转换
批量发送多个请求
</code></pre>
<h2 id="13-axios常用语法"><a href="#13-axios常用语法" class="headerlink" title="13. axios常用语法"></a>13. axios常用语法</h2><pre><code>axios(config): 通用/最本质的发任意类型请求的方式
axios(url[, config]): 可以只指定url发get请求
axios.request(config): 等同于axios(config)
axios.get(url[, config]): 发get请求
axios.delete(url[, config]): 发delete请求
axios.post(url[, data, config]): 发post请求
axios.put(url[, data, config]): 发put请求

axios.defaults.xxx: 请求的默认全局配置
axios.interceptors.request.use(): 添加请求拦截器
axios.interceptors.response.use(): 添加响应拦截器

axios.create([config]): 创建一个新的axios(它没有下面的功能)

axios.Cancel(): 用于创建取消请求的错误对象
axios.CancelToken(): 用于创建取消请求的token对象
axios.isCancel(): 是否是一个取消请求的错误
axios.all(promises): 用于批量执行多个异步请求
axios.spread(): 用来指定接收所有成功数据的回调函数的方法
</code></pre>
<h2 id="14-源码难点与流程分析"><a href="#14-源码难点与流程分析" class="headerlink" title="14. 源码难点与流程分析"></a>14. 源码难点与流程分析</h2><pre><code>1. axios与Axios的关系
    axios函数对应的是Axios.prototype.request方法通过bind(Axiox的实例)产生的函数
    axios有Axios原型上的所有发特定类型请求的方法: get()/post()/put()/delete()
    axios有Axios的实例上的所有属性: defaults/interceptors
    后面又添加了create()/CancelToken()/all()

2. axios.create()返回的对象与axios的区别
    1). 相同: 
        都是一个能发任意请求的函数: request(config)
        都有发特定请求的各种方法: get()/post()/put()/delete()
        都有默认配置和拦截器的属性: defaults/interceptors
    2). 不同:
        默认匹配的值不一样
        instance没有axios后面添加的一引起方法: create()/CancelToken()/all()

3. axios发请求的流程
    1). 整体流程: request(config)  ===&gt; dispatchRequest(config) ===&gt; xhrAdapter(config)
    2). request(config): 将请求拦截器 / dispatchRequest() / 响应拦截器 通过promise链串连起来, 返回promise
    3). dispatchRequest(config): 转换请求数据 ===&gt; 调用xhrAdapter()发请求 ===&gt; 请求返回后转换响应数据. 返回promise
    4). xhrAdapter(config): 创建XHR对象, 根据config进行相应设置, 发送特定请求, 并接收响应数据, 返回promise 
</code></pre>
<p><img src="http://vipkshttp1.wiz.cn/ks/share/resources/49c30824-dcdf-4bd0-af2a-708f490b44a1/584701e2-1d9b-4523-b9b2-0f33e838dd7f/index_files/e5692e36861bd1d2fa1735c5ab801af7.png"></p>
<pre><code>4. axios的请求/响应拦截器是什么?
    1). 请求拦截器: 在真正发请求前, 可以对请求进行检查或配置进行特定处理的函数, 
               包括成功/失败的函数, 传递的必须是config
    2). 响应拦截器: 在请求返回后, 可以对响应数据进行特定处理的函数,
               包括成功/失败的函数, 传递的默认是response
</code></pre>
<p><img src="http://vipkshttp1.wiz.cn/ks/share/resources/49c30824-dcdf-4bd0-af2a-708f490b44a1/584701e2-1d9b-4523-b9b2-0f33e838dd7f/index_files/b0f95169782409e7576bc9704b93b693.png"></p>
<pre><code>5. axios的请求/响应数据转换器是什么?
    1). 请求转换器: 对请求头和请求体数据进行特定处理的函数
        setContentTypeIfUnset(headers, &#39;application/json;charset=utf-8&#39;);
        return JSON.stringify(data)
    2). 响应转换器: 将响应体json字符串解析为js对象或数组的函数
        response.data = JSON.parse(response.data)

6. response的整体结构
    &#123;
        data,
        status,
        statusText,
        headers,
        config,
        request
    &#125;

7. error的整体结构
    &#123;
        message,
        request,
        response
    &#125;

8. 如何取消未完成的请求
    1).当配置了cancelToken对象时, 保存cancel函数
        创建一个用于将来中断请求的cancelPromise
        并定义了一个用于取消请求的cancel函数
        将cancel函数传递出来
    2.调用cancel()取消请求
        执行cacel函数, 传入错误信息message
        内部会让cancelPromise变为成功, 且成功的值为一个Cancel对象
        在cancelPromise的成功回调中中断请求, 并让发请求的proimse失败, 失败的reason为Cacel对象
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2022/08/02/Git/</url>
    <content><![CDATA[<blockquote>
<p>git的一些基础操作</p>
</blockquote>
<span id="more"></span>

<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>版本控制工具</p>
<p>镜像下载地址：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p>
<p>平时一定要多使用这些基础的命令！</p>
<ul>
<li><p>cd : 改变目录。</p>
</li>
<li><p>cd . . 回退到上一个目录，直接cd进入默认目录</p>
</li>
<li><p>pwd : 显示当前所在的目录路径。</p>
</li>
<li><p>ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p>
</li>
<li><p>touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p>
</li>
<li><p>rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p>
</li>
<li><p>mkdir:  新建一个目录,就是新建一个文件夹。</p>
</li>
<li><p>rm -r :  删除一个文件夹, rm -r src 删除src目录</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！</span><br></pre></td></tr></table></figure>

<ul>
<li><p>mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p>
</li>
<li><p>reset 重新初始化终端&#x2F;清屏。</p>
</li>
<li><p>clear 清屏。</p>
</li>
<li><p>history 查看命令历史。</p>
</li>
<li><p>help 帮助。</p>
</li>
<li><p>exit 退出。</p>
</li>
<li><p>#表示注释</p>
</li>
</ul>
<h2 id="git实操"><a href="#git实操" class="headerlink" title="git实操"></a>git实操</h2><ol>
<li>在项目文件夹clone git 仓库</li>
<li>git add . 将所有文件添加到暂存区</li>
<li>git commit -m “修改的一些信息”</li>
<li>git push 提交到远程仓库</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js</title>
    <url>/2022/08/02/Node/</url>
    <content><![CDATA[<blockquote>
<p>Node.js的一些基础操作</p>
</blockquote>
<span id="more"></span>

<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="1-fs-文件系统模块"><a href="#1-fs-文件系统模块" class="headerlink" title="1 fs 文件系统模块"></a>1 fs 文件系统模块</h2><ul>
<li><code>fs.readFile()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;文件路径&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)	 </span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fs.writeFile()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;文件路径&#x27;</span>,<span class="string">&#x27;写入内容&#x27;</span>,<span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功！&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__dirname</code>表示当前文件所处的目录</li>
</ul>
<p>​	在使用fs模块操作文件时，若果提供的操作路径是以.&#x2F;或..&#x2F;开头的相对路径时，很容易出现动态路径拼接错误的问题。</p>
<p>​	原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(__dirname + <span class="string">&#x27;/files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, dataStr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件失败！&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件成功！&#x27;</span> + dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="2-path-路径模块"><a href="#2-path-路径模块" class="headerlink" title="2 path 路径模块"></a>2 path 路径模块</h2><ul>
<li><p><code>path.join()</code></p>
</li>
<li><p><code>path.basename()</code></p>
</li>
<li><p><code>path.extname()</code></p>
</li>
</ul>
<h2 id="3-http-模块"><a href="#3-http-模块" class="headerlink" title="3 http 模块"></a>3 http 模块</h2><ul>
<li>创建基本的web服务器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 创建 web 服务器实例</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"><span class="comment">// 3. 为服务器实例绑定 request 事件，监听客户端的请求</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Someone visit our web server.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 4. 启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>* </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 http 模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 创建 web 服务器实例</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"><span class="comment">// 3. 为服务器实例绑定 request 事件，监听客户端的请求</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 发送到内容</span></span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`您请求的URL地址时<span class="subst">$&#123;req.url&#125;</span>,请求的method类型为<span class="subst">$&#123;req.method&#125;</span>`</span></span><br><span class="line">  <span class="comment">// 设置响应头，防止中文显示乱码的问题</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;text/html;charset=utf-8&#x27;</span>)</span><br><span class="line">  <span class="comment">// 把需要发送的内容交给客户端</span></span><br><span class="line">  res.<span class="title function_">end</span>(str)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 4. 启动服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-模块化"><a href="#4-模块化" class="headerlink" title="4 模块化"></a>4 模块化</h2><ul>
<li><code>moudle.exports</code> 向外暴露一个对象，也可以简写成<code>exprots</code></li>
<li><code>require(&#39;&#39;)</code> 导入模块</li>
</ul>
<h2 id="5-npm"><a href="#5-npm" class="headerlink" title="5 npm"></a>5 npm</h2><ul>
<li><code>npm init -y</code>快速创建·<code>package.json</code>包管理文件，可以记录下载的包</li>
<li>项目中执<code>npm install</code>可以查找<code>packa.json</code>文件中的<code>dependencies</code>并下载所有包</li>
<li><code>npm i 包名 -D</code> 将包记录到<code>devDependencies</code>节点，这些包只在项目开发中用到</li>
<li><code>npm config get registry</code> 查看当前的下包镜像源</li>
<li><code>npm i nrm -g</code>下载nrm</li>
<li><code>nrm ls</code> 查看可用的镜像源</li>
<li><code>nrm use</code> 名称 切换镜像源</li>
</ul>
<h2 id="6-express"><a href="#6-express" class="headerlink" title="6 express"></a>6 express</h2><ul>
<li>创建基本的web服务器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;express server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>app.get()</code> 方法，可以监听客户端的GET请求</li>
<li><code>app.post()</code> 方法，可以监听客户端的POST请求</li>
<li><code>res.send()</code>方法，向客户端响应内容</li>
<li><code>req.query()</code>方法，可以获取客户端请求的查询参数</li>
<li><code>req.parmas()</code>方法，可以访问到url中，通过：匹配得到的动态参数</li>
<li><code>req.body()</code>方法，获取客户端发过来的请求体数据，</li>
<li><code>express.static()</code>方法，对外提供静态资源</li>
<li>express 模块化路由</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use(&#x27;/files&#x27;, express.static(&#x27;./files&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./03.router&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 注册路由模块</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意： app.use() 函数的作用，就是来注册全局中间件</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是路由模块</span></span><br><span class="line"><span class="comment">// 1. 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 挂载具体的路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user/list&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Get user list.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/user/add&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Add new user.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 向外导出路由对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>全局中间件：<code>app.use((req,res,next)=&gt;&#123;next()&#125;)</code></li>
<li>局部生效的中间件：直接在路由中间加个中间件函数，</li>
</ul>
<p>​		<code>app.get(&#39;/user&#39;,mw,(req,res)=&gt;&#123;&#125;)</code></p>
<p>​		mw就是中间件函数</p>
<ul>
<li><p>注意事项：</p>
<ul>
<li>中间件一定要在路由之前注册（错误级别中间件除外）</li>
<li>中间件函数不要忘记next()</li>
<li>next()函数不要再写额外的代码</li>
<li>连续调用多个中间件时，多个中间件之间，共享req和res对象</li>
</ul>
</li>
<li><p>错误级别中间件：<code>app.use((err,req,res,next)=&gt;&#123;&#125;)</code></p>
</li>
<li><p>express内置中间件：</p>
<ul>
<li><code>express.static</code>快速托管静态资源</li>
<li><code>express.json 解析JSON格式的请求体数据</code></li>
<li><code>express.urlencoded 解析URL-encoded格式的请求体数据</code>需要设置<code>extend：false</code></li>
</ul>
</li>
<li><p>解决跨域问题</p>
<ul>
<li><code>npm i cors</code></li>
<li><code>require(&#39;cors&#39;)</code></li>
<li><code>app.use(cors())</code></li>
</ul>
</li>
<li><p>cors 跨域资源共享</p>
<ul>
<li>cors 响应头部 <code>Access-Control-Allow-Origin</code>可以配置指定的域名访问，*表示任何域名都可访问</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Access-Control-Allow-Method</code>,可以配置请求方式为put，delete，*表示允许所有请求方式</li>
</ul>
</li>
</ul>
<h2 id="7-数据库"><a href="#7-数据库" class="headerlink" title="7 数据库"></a>7 数据库</h2><ul>
<li><code>mysql</code>数据库操作：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use my_db_01; -- 使用数据库</span><br><span class="line"></span><br><span class="line">select * from users; -- 查询users表的所有信息</span><br><span class="line"></span><br><span class="line">select id,username from users; -- 查询users表中的id,username字段</span><br><span class="line"></span><br><span class="line">insert into users (username,password) value (&#x27;tom&#x27;,&#x27;123456&#x27;) -- 插入数据</span><br><span class="line"></span><br><span class="line">update users set password=&#x27;888888&#x27; where id=4 -- 更新数据</span><br><span class="line"></span><br><span class="line">update users set password=&#x27;1234&#x27;,status=&#x27;1&#x27; where id=2 --更新数据</span><br><span class="line"></span><br><span class="line">delete from users where id=4 -- 删除id为4的数据</span><br><span class="line"></span><br><span class="line">select * from users where id&lt;3 and status=0 -- 查询id小于3，和status等于0的数据</span><br><span class="line"></span><br><span class="line">select * from users order by id desc -- 对users表通过id排序，desc降序，默认升序</span><br><span class="line"></span><br><span class="line">select * from users order by status desc, username -- 先对status进行降序排序，然后对username进行升序排列</span><br><span class="line"></span><br><span class="line">select count(*) as total from users where status=0 -- 统计status=0的数据总数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>项目中操作数据库</p>
<ul>
<li><p>安装mysql<code>npm i mysql</code></p>
</li>
<li><p>导入mysql模块<code>require(&#39;mysql&#39;)</code></p>
</li>
<li><p>建立与mysql数据库的连接:</p>
</li>
<li><p>&#96;&#96;&#96;js<br>const db &#x3D; mysql.createPool({<br>host: ‘127.0.0.1’,     &#x2F;&#x2F;数据库的IP地址<br>user: ‘root’,		   &#x2F;&#x2F;登录数据库的账号<br>password: ‘admin123’,  &#x2F;&#x2F;登录数据库的密码<br>database: ‘my_db_01’   &#x2F;&#x2F;指定操作哪个数据库<br>})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* `db.query()`函数，指定要执行的SQL语句，通过回调函数拿到执行的结果</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">db.query(&#x27;select 1&#x27;,(err,results)=&gt;&#123;</span><br><span class="line">    if(err) return console.log(err.message)</span><br><span class="line">    console.log(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意db.query()函数如果是执行的查询语句，返回的结果是一个数组</p>
</li>
<li><p>向 users 表中，新增一条数据，其中 username 的值为 tom ，password 的值为 666666</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">username</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">password</span>: <span class="string">&#x27;666666&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 问好可以占位，</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;insert into users (username,password) values (?,?)&#x27;</span></span><br><span class="line"><span class="comment">// 中括号的数据会依次填入？占位中去</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr,[user.<span class="property">username</span>,user.<span class="property">password</span>],<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  <span class="comment">// results中的affectedRows属性等于1表示数据插入成功</span></span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入数据成功！&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入数据的便捷方式：如果数据对象的每个属性和数据表的字段一一对应，就可以使用如下方式快速插入数据：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">username</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">password</span>: <span class="string">&#x27;666666&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;insert into users set ?&#x27;</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr,user,<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入数据成功！&#x27;</span>)&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>更新用户的信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>: <span class="number">6</span>,<span class="attr">username</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">password</span>: <span class="string">&#x27;666666&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;update users set username=?,password=? where id=?&#x27;</span></span><br><span class="line"></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr,[user.<span class="property">username</span>,user.<span class="property">password</span>,user.<span class="property">id</span>],<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新成功！&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 便捷方式</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>: <span class="number">6</span>,<span class="attr">username</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">password</span>: <span class="string">&#x27;666666&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;update users set ? where id=?&#x27;</span></span><br><span class="line"></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr,[user,user.<span class="property">id</span>],<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新成功！&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;delete from users where id=?&#x27;</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr,<span class="number">7</span>,<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除数据成功！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据比较危险，无法修复，可以设置状态值来标记删除，当用户执行删除动作时并不会删除数据，而是更新status字段，标记为删除</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;update users set status=1 where id=?&#x27;</span>,<span class="number">6</span>,<span class="function">(<span class="params">err,results</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除数据成功！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="8-身份认证"><a href="#8-身份认证" class="headerlink" title="8 身份认证"></a>8 身份认证</h2><p>对于服务器端渲染推荐使用Session认证机制</p>
<p>对于前后端分离推荐使用JWT认证机制</p>
<ul>
<li>express 中使用session 认证（非跨域）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置session</span></span><br><span class="line">npm i express-session</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&#x27;keyboard cat&#x27;</span>,</span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">true</span> </span><br><span class="line">&#125;))</span><br><span class="line"><span class="comment">// 通过req.session来访问和使用session对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JWT 认证机制（跨域）<code>npm i jsonwebtoken express-jwt</code></li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2022/08/05/Vue/</url>
    <content><![CDATA[<blockquote>
<p>vue的学习笔记</p>
</blockquote>
<span id="more"></span>

<h1 id="VUE笔记"><a href="#VUE笔记" class="headerlink" title="VUE笔记"></a>VUE笔记</h1><h2 id="VUE基础"><a href="#VUE基础" class="headerlink" title="VUE基础"></a>VUE基础</h2><h3 id="1-创建Vue实例"><a href="#1-创建Vue实例" class="headerlink" title="1. 创建Vue实例"></a>1. 创建Vue实例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>, <span class="comment">// el用于指定当前Vue实例为哪个容器服务</span></span><br><span class="line">    <span class="attr">data</span>: &#123; <span class="comment">// data 用于存储数据，数据供el所指定的容器去使用</span></span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注意：一个容器只对应一个实例</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Vue模板语法有2大类："><a href="#2-Vue模板语法有2大类：" class="headerlink" title="2. Vue模板语法有2大类："></a>2. Vue<strong>模板语法</strong>有2大类：</h3><p>​          1.插值语法：</p>
<p>​              功能：用于解析标签体内容。</p>
<p>​              写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</p>
<p>​          2.指令语法：</p>
<p>​              功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。</p>
<p>​              举例：v-bind:href&#x3D;”xxx” 或  简写为 :href&#x3D;”xxx”，xxx同样要写js表达式，</p>
<p>​                   且可以直接读取到data中的所有属性。</p>
<p>​              备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</p>
<h3 id="3-Vue中有2种数据绑定的方式："><a href="#3-Vue中有2种数据绑定的方式：" class="headerlink" title="3. Vue中有2种数据绑定的方式："></a>3. Vue中有2种<strong>数据绑定</strong>的方式：</h3><p>​          1.单向绑定(v-bind)：数据只能从data流向页面。</p>
<p>​          2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p>
<p>​            备注：</p>
<p>​                1.双向绑定一般都应用在表单类元素上（如：input、select等）</p>
<p>​                2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
<h3 id="4-data与el的2种写法"><a href="#4-data与el的2种写法" class="headerlink" title="4. data与el的2种写法"></a>4. data与el的2种写法</h3><p>​          1.el有2种写法</p>
<p>​                  (1).new Vue时候配置el属性。</p>
<p>​                  (2).先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。</p>
<p>​          2.data有2种写法</p>
<p>​                  (1).对象式</p>
<p>​                  (2).函数式: 数据必须return</p>
<p>​                  如何选择：以后学习到组件时，data必须使用函数式，否则会报错。</p>
<p>​          3.一个重要的原则：</p>
<p>​                  由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例.</p>
<h3 id="5-MVVM模型"><a href="#5-MVVM模型" class="headerlink" title="5. MVVM模型"></a>5. MVVM模型</h3><p>​            1. M：模型(Model) ：data中的数据</p>
<p>​            2. V：视图(View) ：模板代码</p>
<p>​            3. VM：视图模型(ViewModel)：Vue实例</p>
<p>​      观察发现：</p>
<p>​            1.data中所有的属性，最后都出现在了vm身上。</p>
<p>​            2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p>
<h3 id="6-Object-defineProperty"><a href="#6-Object-defineProperty" class="headerlink" title="6. Object.defineProperty()"></a>6. Object.defineProperty()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&#x27;age&#x27;</span>,&#123;<span class="comment">//person 属性所在的对象，‘age’,添加的属性</span></span><br><span class="line">    <span class="comment">// value:18,</span></span><br><span class="line">    <span class="comment">// enumerable:true, //控制属性是否可以枚举，默认值是false</span></span><br><span class="line">    <span class="comment">// writable:true, //控制属性是否可以被修改，默认值是false</span></span><br><span class="line">    <span class="comment">// configurable:true //控制属性是否可以被删除，默认值是false</span></span><br><span class="line">    <span class="comment">//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;有人读取age属性了&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;有人修改了age属性，且值是&#x27;</span>,value)</span><br><span class="line">        number = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="7-数据代理"><a href="#7-数据代理" class="headerlink" title="7. 数据代理"></a>7. 数据代理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>:<span class="number">100</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">y</span>:<span class="number">200</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj2,<span class="string">&#x27;x&#x27;</span>,&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.<span class="property">x</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        obj.<span class="property">x</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>1.Vue中的数据代理：</li>
</ul>
<p>​              通过vm对象来代理data对象中属性的操作（读&#x2F;写）</p>
<p>​        2.Vue中数据代理的好处：</p>
<p>​              更加方便的操作data中的数据</p>
<p>​        3.基本原理：</p>
<p>​              通过Object.defineProperty()把data对象中所有属性添加到vm上。</p>
<p>​              为每一个添加到vm上的属性，都指定一个getter&#x2F;setter。</p>
<p>​              在getter&#x2F;setter内部去操作（读&#x2F;写）data中对应的属性。</p>
<h3 id="8-事件的基本使用："><a href="#8-事件的基本使用：" class="headerlink" title="8. 事件的基本使用："></a>8. 事件的基本使用：</h3><p>​              1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p>
<p>​              2.事件的回调需要配置在methods对象中，最终会在vm上；</p>
<p>​              3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p>
<p>​              4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p>
<p>​              5.@click&#x3D;”demo” 和 @click&#x3D;”demo($event)” 效果一致，但后者可以传参；</p>
<ul>
<li><pre><code>   Vue中的事件修饰符：
</code></pre>
</li>
</ul>
<p>​            1.prevent：阻止默认事件（常用）；</p>
<p>​            2.stop：阻止事件冒泡（常用）；</p>
<p>​            3.once：事件只触发一次（常用）；</p>
<p>​            4.capture：使用事件的捕获模式；</p>
<p>​            5.self：只有event.target是当前操作的元素时才触发事件；</p>
<p>​            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p>
<ul>
<li><pre><code>   1.Vue中常用的按键别名：
</code></pre>
</li>
</ul>
<p>​              回车 &#x3D;&gt; enter</p>
<p>​              删除 &#x3D;&gt; delete (捕获“删除”和“退格”键)</p>
<p>​              退出 &#x3D;&gt; esc</p>
<p>​              空格 &#x3D;&gt; space</p>
<p>​              换行 &#x3D;&gt; tab (特殊，必须配合keydown去使用)</p>
<p>​              上 &#x3D;&gt; up</p>
<p>​              下 &#x3D;&gt; down</p>
<p>​              左 &#x3D;&gt; left</p>
<p>​              右 &#x3D;&gt; right</p>
<p>​        2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p>
<p>​        3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p>
<p>​              (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p>
<p>​              (2).配合keydown使用：正常触发事件。</p>
<p>​        4.也可以使用keyCode去指定具体的按键（不推荐）</p>
<p>​        5.Vue.config.keyCodes.自定义键名 &#x3D; 键码，可以去定制按键别名</p>
<h3 id="9-计算属性："><a href="#9-计算属性：" class="headerlink" title="9. 计算属性："></a>9. 计算属性：</h3><p>​          1.定义：要用的属性不存在，要通过已有属性计算得来。</p>
<p>​          2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</p>
<p>​          3.get函数什么时候执行？</p>
<p>​                (1).初次读取时会执行一次。</p>
<p>​                (2).当依赖的数据发生改变时会被再次调用。</p>
<p>​          4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p>
<p>​          5.备注：</p>
<p>​              1.计算属性最终会出现在vm上，直接读取使用即可。</p>
<p>​              2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p>
<h3 id="10-监视属性watch："><a href="#10-监视属性watch：" class="headerlink" title="10. 监视属性watch："></a>10. 监视属性watch：</h3><p>​          1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p>
<p>​          2.监视的属性必须存在，才能进行监视！！</p>
<p>​          3.监视的两种写法：</p>
<p>​              (1).new Vue时传入watch配置</p>
<p>​              (2).通过vm.$watch监视</p>
<ul>
<li><pre><code>   深度监视：
</code></pre>
</li>
</ul>
<p>​            (1).Vue中的watch默认不监测对象内部值的改变（一层）。</p>
<p>​            (2).配置deep:true可以监测对象内部值改变（多层）。</p>
<p>​        备注：</p>
<p>​            (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</p>
<p>​            (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</p>
<h3 id="11-computed和watch之间的区别："><a href="#11-computed和watch之间的区别：" class="headerlink" title="11. computed和watch之间的区别："></a>11. computed和watch之间的区别：</h3><p>​            1.computed能完成的功能，watch都可以完成。</p>
<p>​            2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p>
<p>​        两个重要的小原则：</p>
<p>​              1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p>
<p>​              2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，</p>
<p>​                这样this的指向才是vm 或 组件实例对象。</p>
<h3 id="12-绑定样式："><a href="#12-绑定样式：" class="headerlink" title="12. 绑定样式："></a>12. 绑定样式：</h3><p>​          1. class样式</p>
<p>​                写法:class&#x3D;”xxx” xxx可以是字符串、对象、数组。</p>
<p>​                    字符串写法适用于：类名不确定，要动态获取。</p>
<p>​                    对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p>
<p>​                    数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p>
<p>​          2. style样式</p>
<p>​                :style&#x3D;”{fontSize: xxx}”其中xxx是动态值。</p>
<p>​                :style&#x3D;”[a,b]”其中a、b是样式对象。</p>
<h3 id="13-条件渲染："><a href="#13-条件渲染：" class="headerlink" title="13. 条件渲染："></a>13. 条件渲染：</h3><p>​              1.v-if</p>
<p>​                    写法：</p>
<p>​                        (1).v-if&#x3D;”表达式” </p>
<p>​                        (2).v-else-if&#x3D;”表达式”</p>
<p>​                        (3).v-else&#x3D;”表达式”</p>
<p>​                    适用于：切换频率较低的场景。</p>
<p>​                    特点：不展示的DOM元素直接被移除。</p>
<p>​                    注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p>
<p>​              2.v-show</p>
<p>​                    写法：v-show&#x3D;”表达式”</p>
<p>​                    适用于：切换频率较高的场景。</p>
<p>​                    特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p>
<p>​              3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p>
<ul>
<li><pre><code>   v-for指令:
</code></pre>
</li>
</ul>
<p>​            1.用于展示列表数据</p>
<p>​            2.语法：v-for&#x3D;”(item, index) in xxx” :key&#x3D;”yyy”</p>
<p>​            3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p>
<ul>
<li><pre><code>           面试题：react、vue中的key有什么作用？（key的内部原理）
</code></pre>
</li>
</ul>
<ol>
<li>虚拟DOM中key的作用：<br>变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</li>
<li>对比规则：</li>
</ol>
<p>​      (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：</p>
<p>​            ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</p>
<p>​            ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p>
<p>​      (2).旧虚拟DOM中未找到与新虚拟DOM相同的key</p>
<p>​            创建新的真实DOM，随后渲染到到页面。                                                </p>
<ol start="3">
<li><p>用index作为key可能会引发的问题：</p>
<ol>
<li><p>破坏顺序操作:<br>会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p>
</li>
<li><p>如果结构中还包含输入类的DOM：<br>   会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p>
</li>
</ol>
</li>
<li><p>开发中如何选择key?:<br>   1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>   2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>   使用index作为key是没有问题的。</p>
</li>
</ol>
<ul>
<li>Vue监视数据的原理：</li>
</ul>
<p>​      1. vue会监视data中所有层次的数据。</p>
<p>​      2. 如何监测对象中的数据？</p>
<p>​        通过setter实现监视，且要在new Vue时就传入要监测的数据。</p>
<p>​          (1).对象中后追加的属性，Vue默认不做响应式处理</p>
<p>​          (2).如需给后添加的属性做响应式，请使用如下API：</p>
<p>​            Vue.set(target，propertyName&#x2F;index，value) 或 </p>
<p>​            vm.$set(target，propertyName&#x2F;index，value)</p>
<p>​      3. 如何监测数组中的数据？</p>
<p>​        通过包裹数组更新元素的方法实现，本质就是做了两件事：</p>
<p>​          (1).调用原生对应的方法对数组进行更新。</p>
<p>​          (2).重新解析模板，进而更新页面。</p>
<p>​      4.在Vue修改数组中的某个元素一定要用如下方法：</p>
<p>​        1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p>
<p>​        2.Vue.set() 或 vm.$set()</p>
<p>​      特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p>
<h3 id="13-收集表单数据："><a href="#13-收集表单数据：" class="headerlink" title="13. 收集表单数据："></a>13. 收集表单数据：</h3><p>​      若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。</p>
<p>​      若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。</p>
<p>​      若：<input type="checkbox"/></p>
<p>​        1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
<p>​        2.配置input的value属性:</p>
<p>​            (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
<p>​            (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p>
<p>​      备注：v-model的三个修饰符：</p>
<p>​        lazy：失去焦点再收集数据</p>
<p>​        number：输入字符串转为有效的数字</p>
<p>​        trim：输入首尾空格过滤</p>
<h3 id="14-我们学过的指令："><a href="#14-我们学过的指令：" class="headerlink" title="14. 我们学过的指令："></a>14. 我们学过的指令：</h3><p>​      v-bind  : 单向绑定解析表达式, 可简写为 :xxx</p>
<p>​      v-model : 双向数据绑定</p>
<p>​      v-for  : 遍历数组&#x2F;对象&#x2F;字符串</p>
<p>​      v-on   : 绑定事件监听, 可简写为@</p>
<p>​      v-if     : 条件渲染（动态控制节点是否存存在）</p>
<p>​      v-else  : 条件渲染（动态控制节点是否存存在）</p>
<p>​      v-show  : 条件渲染 (动态控制节点是否展示)</p>
<pre><code>  v-text指令：
</code></pre>
<p>​      	1.作用：向其所在的节点中渲染文本内容。</p>
<p>​      	2.与插值语法的区别：v-text会替换掉节点中的内容，则不会。</p>
<p>​	  v-html指令：</p>
<p>​      	1.作用：向指定节点中渲染包含html结构的内容。</p>
<p>​     	 2.与插值语法的区别：</p>
<p>​        	(1).v-html会替换掉节点中所有的内容，则不会。</p>
<p>​        	(2).v-html可以识别html结构。</p>
<p>​      	3.严重注意：v-html有安全性问题！！！！</p>
<p>​        	(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p>
<p>​        	(2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p>
<p>​	   v-cloak指令（没有值）：</p>
<p>​      	1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p>
<p>​      	2.使用css配合v-cloak可以解决网速慢时页面展示出的问题。</p>
<p>​	   v-once指令：</p>
<p>​      	1.v-once所在节点在初次动态渲染后，就视为静态内容了。</p>
<p>​      	2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p>
<p>​	   v-pre指令：</p>
<p>​      	1.跳过其所在节点的编译过程。</p>
<p>​      	2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p>
<h3 id="15-生命周期"><a href="#15-生命周期" class="headerlink" title="15. 生命周期"></a>15. <strong>生命周期</strong></h3><ul>
<li><p>beforCreate(): 此时无法访问到data中的数据，methods中的方法。</p>
</li>
<li><p>created(): 可以通过vm访问到data中的数据，methods中配置的方法。</p>
</li>
<li><p>beforMount(): 此时呈现的是未经Vue编译的DOM结构，所有DOM操作，最终都不奏效。</p>
</li>
<li><p>mounted():此阶段呈现经过Vue编译的DOM，一般在此阶段进行：开启定时器、发送网络请求、订阅消息、绑定自定义事件等</p>
</li>
<li><p>beforUpdate(): 数据是新的，但页面是旧的，此时页面还未更新</p>
</li>
<li><p>updated(): 此时数据，和页面都更新了。</p>
</li>
<li><p>beforDistroy(): vm中的所有data、methods、指令等，都处于可用状态马上要执行销毁过程，一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等</p>
</li>
<li><p>distroy(): </p>
</li>
<li><p>常用的生命周期钩子：</p>
<p>​      1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p>
<p>​      2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p>
<p>​    关于销毁Vue实例</p>
<p>​      1.销毁后借助Vue开发者工具看不到任何信息。</p>
<p>​      2.销毁后自定义事件会失效，但原生DOM事件依然有效。</p>
<p>​      3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p>
</li>
</ul>
<h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">	<span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line">	<span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line">	<span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ol>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p> 第一步定义混合：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 第二步使用混入：</p>
<p> ​	全局混入：<code>Vue.mixin(xxx)</code><br> ​	局部混入：<code>mixins:[&#39;xxx&#39;]	</code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol>
<li><p>组件化编码流程：</p>
<p> ​	(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p> ​	(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p> ​			1).一个组件在用：放在组件自身即可。</p>
<p> ​			2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p> ​	(3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props适用于：</p>
<p> ​	(1).父组件 &#x3D;&#x3D;&gt; 子组件 通信</p>
<p> ​	(2).子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p> ​		该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p> ​		该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p> ​		该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code>		</p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">	&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" /></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
<li><p>第三方库：npm 里面的 Animated</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​	在vue.config.js中添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​	编写vue.config.js配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具名插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">				&lt;ul&gt;</span><br><span class="line">					&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">				&lt;/ul&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">			&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">				&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​		在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​		多个组件需要共享数据时</p>
<p>​		<code>npm i vuex</code></p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">	store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line">	<span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">		context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line">	<span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">		state.<span class="property">sum</span> += value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">	<span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定展示位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用children配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">		<span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转（要写完整路径）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简化跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;hello&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol>
<li><p>配置路由，声明接收params参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数，加问号表示可传可不传</span></span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;xiangqing&#x27;,</span><br><span class="line">		params:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​	作用：让路由组件更方便的收到参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:true</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">	<span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">			<span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">		<span class="attr">params</span>:&#123;</span><br><span class="line">			<span class="attr">id</span>:xxx,</span><br><span class="line">			<span class="attr">title</span>:xxx</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line">			<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>独享守卫:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件内守卫：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-next优化</title>
    <url>/2022/08/03/hexo-next%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title>函数防抖和节流</title>
    <url>/2022/08/05/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<blockquote>
<p>函数防抖和节流： 节约计算机资源，提升用户体验。</p>
</blockquote>
<span id="more"></span>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>模拟在输入框输入后做ajax查询请求，没有加入防抖和节流的效果，这里附上完整可执行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>节流和防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 模拟ajax请求</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">content</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ajax request &#x27;</span> + content)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> inputNormal = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;normal&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            inputNormal.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">ajax</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        1.没有防抖的输入：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;normal&quot;</span> <span class="attr">id</span>=<span class="string">&quot;normal&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：在输入框里输入一个，就会触发一次‘ajax请求’。（这里是console）</p>
<p><img src="/../images/nofdjl.png"></p>
<p>没有防抖和节流</p>
<p>缺点：浪费请求资源。用户输入‘防抖’两个字，就执行了8次‘ajax请求’，而用户只需要最后一次请求。</p>
<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><h3 id="1-1-什么是防抖"><a href="#1-1-什么是防抖" class="headerlink" title="1.1 什么是防抖"></a>1.1 什么是防抖</h3><p>在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时。</p>
<h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a>1.2 应用场景</h3><p>(1) 用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源；</p>
<p>(2) window的resize、scroll事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次；</p>
<h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h3><p>加入防抖优化</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>节流和防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 模拟ajax请求</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">content</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ajax request &#x27;</span> + content)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 防抖</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,delay</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> args = <span class="variable language_">arguments</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript">                    timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args);</span></span><br><span class="line"><span class="language-javascript">                    &#125;,delay);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> inputNormal = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;normal&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> debounceAjax = <span class="title function_">debounce</span>(ajax, <span class="number">500</span>)</span></span><br><span class="line"><span class="language-javascript">            inputNormal.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">debounceAjax</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        2.加入防抖后的输入：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;normal&quot;</span> <span class="attr">id</span>=<span class="string">&quot;normal&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>每一次事件被触发，都会清除当前的timer然后重新计时。这就会导致高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发；</li>
<li>只有当高频事件停止，最后一次事件触发的超时调用才能在delay时间后执行；</li>
</ol>
<p>效果：</p>
<p>加入防抖后，当持续在输入框里输入时，并不会发送请求，只有当在指定时间间隔内没有再输入时，才会发送请求。如果先停止输入，但是在指定间隔内又输入，会重新触发计时。</p>
<p><img src="/../images/fd.png"></p>
<p>加入防抖后，只发送了一次请求。</p>
<h2 id="2-节流（throttle）"><a href="#2-节流（throttle）" class="headerlink" title="2.节流（throttle）"></a>2.节流（throttle）</h2><h3 id="2-1-什么是节流"><a href="#2-1-什么是节流" class="headerlink" title="2.1 什么是节流"></a>2.1 什么是节流</h3><p>规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被多次触发，只有一次能生效。</p>
<h3 id="2-2-应用场景"><a href="#2-2-应用场景" class="headerlink" title="2.2 应用场景"></a>2.2 应用场景</h3><p>(1)鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；</p>
<p>(2)在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据；</p>
<p>(3)监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断；</p>
<h2 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3  实现"></a>2.3  实现</h2><p>通过定时器设置单位时间，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>节流和防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//模拟ajax请求</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">content</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ajax request &#x27;</span> + content)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> last, deferTimer</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">let</span> _args = <span class="variable language_">arguments</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (last &amp;&amp; now &lt; last + delay) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="built_in">clearTimeout</span>(deferTimer);</span></span><br><span class="line"><span class="language-javascript">                        deferTimer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                            last = now;</span></span><br><span class="line"><span class="language-javascript">                            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, _args);</span></span><br><span class="line"><span class="language-javascript">                        &#125;, delay)</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        last = now;</span></span><br><span class="line"><span class="language-javascript">                        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, _args);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> throttleAjax = <span class="title function_">throttle</span>(ajax, <span class="number">3000</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> inputNormal = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;normal&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            inputNormal.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">throttleAjax</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        3.加入节流后的输入：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;normal&quot;</span> <span class="attr">id</span>=<span class="string">&quot;normal&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：实验可发现在持续输入时，会按照代码中的设定，每2秒执行一次’ajax请求‘</p>
<p><img src="/../images/jl.png"></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>总结下防抖和节流的区别：</p>
<p>– 效果：</p>
<p>函数防抖是某一段时间内只执行一次；而函数节流是间隔时间执行，不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。</p>
<p>– 原理：</p>
<p>防抖是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，都会清除当前的 timer 然后重新设置超时调用，即重新计时。这样一来，只有最后一次操作能被触发。</p>
<p>节流是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2022/08/02/Promise/</url>
    <content><![CDATA[<blockquote>
<p>Promise学习，以及手写Promise</p>
</blockquote>
<span id="more"></span>

<h1 id="Promise深入-自定义Promise"><a href="#Promise深入-自定义Promise" class="headerlink" title="Promise深入 + 自定义Promise"></a>Promise深入 + 自定义Promise</h1><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><h3 id="1-1-函数对象与实例对象"><a href="#1-1-函数对象与实例对象" class="headerlink" title="1.1. 函数对象与实例对象"></a>1.1. 函数对象与实例对象</h3><pre><code>1. 函数对象: 将函数作为对象使用时, 简称为函数对象
2. 实例对象: new 函数产生的对象, 简称为对象
</code></pre>
<h3 id="1-2-回调函数的分类"><a href="#1-2-回调函数的分类" class="headerlink" title="1.2. 回调函数的分类"></a>1.2. 回调函数的分类</h3><pre><code>1. 同步回调: 
    理解: 立即执行, 完全执行完了才结束, 不会放入回调队列中
    例子: 数组遍历相关的回调函数 / Promise的excutor函数
2. 异步回调: 
    理解: 不会立即执行, 会放入回调队列中将来执行
    例子: 定时器回调 / ajax回调 / Promise的成功|失败的回调
</code></pre>
<h3 id="1-3-JS中的Error"><a href="#1-3-JS中的Error" class="headerlink" title="1.3. JS中的Error"></a>1.3. JS中的Error</h3><pre><code>1. 错误的类型
    Error: 所有错误的父类型
    ReferenceError: 引用的变量不存在
    TypeError: 数据类型不正确的错误
    RangeError: 数据值不在其所允许的范围内
    SyntaxError: 语法错误
2. 错误处理
    捕获错误: try ... catch
    抛出错误: throw error
3. 错误对象
    message属性: 错误相关信息
    stack属性: 函数调用栈记录信息
</code></pre>
<h2 id="2-Promise的理解和使用"><a href="#2-Promise的理解和使用" class="headerlink" title="2. Promise的理解和使用"></a>2. Promise的理解和使用</h2><h3 id="2-1-Promise是什么"><a href="#2-1-Promise是什么" class="headerlink" title="2.1. Promise是什么?"></a>2.1. Promise是什么?</h3><pre><code>1.抽象表达: 
    Promise是JS中进行异步编程的新的解决方案(旧的是谁?)
2.具体表达:
    从语法上来说: Promise是一个构造函数
    从功能上来说: promise对象用来封装一个异步操作并可以获取其结果
3. promise的状态改变(只有2种, 只能改变一次)
    pending变为resolved
    pending变为rejected
4. promise的基本流程
</code></pre>
<p><img src="http://vipkshttp1.wiz.cn/ks/share/resources/49c30824-dcdf-4bd0-af2a-708f490b44a1/92b8cbfb-a474-4859-943b-6048e9dc66f6/index_files/9b2b980e2959c4f996cafddb03fa5d4d.png" alt="promise基本流程"></p>
<h3 id="2-2-为什么要用Promise"><a href="#2-2-为什么要用Promise" class="headerlink" title="2.2. 为什么要用Promise?"></a>2.2. 为什么要用Promise?</h3><ol>
<li>指定回调函数的方式更加灵活: 可以在请求发出甚至结束后指定回调函数<ul>
<li>使用纯回调函数：<ul>
<li>在执行异步操作之前就必须指定回调函数；</li>
</ul>
</li>
<li>使用promise：<ul>
<li>可以随时去绑定回调函数</li>
</ul>
</li>
</ul>
</li>
<li>支持链式调用, 可以解决回调地狱问题（不便于阅读、不便于处理异常）<ul>
<li>使用纯回调函数：<ul>
<li>当回调函数嵌套调用，外部回调函数异步执行的结果时嵌套的回调函数执行的条件时，回产生回调地狱的问题</li>
</ul>
</li>
<li>使用promise：<ul>
<li>promise支持链式调用，可以通过cath()方法处理异常</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-3-如何使用Promise"><a href="#2-3-如何使用Promise" class="headerlink" title="2.3. 如何使用Promise?"></a>2.3. 如何使用Promise?</h3><pre><code>1. 主要API
    Promise构造函数: Promise (excutor) &#123;&#125;
    Promise.prototype.then方法: (onResolved, onRejected) =&gt; &#123;&#125;
    Promise.prototype.catch方法: (onRejected) =&gt; &#123;&#125;
    Promise.resolve方法: (value) =&gt; &#123;&#125;
    Promise.reject方法: (reason) =&gt; &#123;&#125;
    Promise.all方法: (promises) =&gt; &#123;&#125;
    Promise.race方法: (promises) =&gt; &#123;&#125;
2. 几个重要问题
    如何改变promise的状态?
    一个promise指定多个成功/失败回调函数, 都会调用吗?
    promise.then()返回的新promise的结果状态由什么决定?
    改变promise状态和指定回调函数谁先谁后?
    promise如何串连多个操作任务?
    promise异常传(穿)透?
    中断promise链
</code></pre>
<h2 id="3-自定义Promise"><a href="#3-自定义Promise" class="headerlink" title="3. 自定义Promise"></a>3. 自定义Promise</h2><ol>
<li>定义整体结构（Promise的主要API）</li>
<li>Promise构造函数的实现</li>
<li>promise.then()&#x2F;catch()的实现</li>
<li>Promise.resolve()&#x2F;reject()的实现</li>
<li>Promise.all&#x2F;race()的实</li>
<li>Promise.resolveDelay()&#x2F;rejectDelay()的实现</li>
<li>ES6 class版本</li>
</ol>
<h2 id="4-async与await"><a href="#4-async与await" class="headerlink" title="4. async与await"></a>4. async与await</h2><pre><code>1. async 函数
    函数的返回值为promise对象
    promise对象的结果由async函数执行的返回值决定
   
2. await 表达式
    await右侧的表达式一般为promise对象, 但也可以是其它的值
    如果表达式是promise对象, await返回的是promise成功的值
    如果表达式是其它值, 直接将此值作为await的返回值

3. 注意:
    await必须写在async函数中, 但async函数中可以没有await
    如果await的promise失败了, 就会抛出异常, 需要通过try...catch来捕获处理
</code></pre>
<h2 id="5-JS异步之宏队列与微队列"><a href="#5-JS异步之宏队列与微队列" class="headerlink" title="5. JS异步之宏队列与微队列"></a>5. JS异步之宏队列与微队列</h2><p><img src="http://vipkshttp1.wiz.cn/ks/share/resources/49c30824-dcdf-4bd0-af2a-708f490b44a1/92b8cbfb-a474-4859-943b-6048e9dc66f6/index_files/60b9ff398449db2dcfef9197e2187ae6.png" alt="宏队列与微队列"></p>
<pre><code>1. 宏列队: 用来保存待执行的宏任务(回调), 比如: 定时器回调/DOM事件回调/ajax回调
2. 微列队: 用来保存待执行的微任务(回调), 比如: promise的回调/MutationObserver的回调
3. JS执行时会区别这2个队列
    JS引擎首先必须先执行所有的初始化同步任务代码
    每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行
</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
</search>
